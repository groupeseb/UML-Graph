<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
    stroke: #999;
    stroke-opacity: 0.6;
}

.nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
}

text {
    font-family: sans-serif;
    font-size: 11px;
}
    
</style>
<svg width="2048" height="1024"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script>

var min = 0;

var graph = {
    nodes: new Map(),
    links: []
}

var coords = new Array(100).fill(0);

const colors = {
    Entrypoint: 1,
    Node: 5,
    Exitpoint: 10
}

const dist_h = 300
const dist_v = 100
const node_width = 200
const node_heigth = 40
const radio = 12

$(document).ready(function(){
    $.ajax({
        type: "GET" ,
        url: "routes.csv" ,
        dataType: "text" ,
        success: function(csv) {

            var lines = csv.split(/\r\n|\n/)
            var header = lines[0].split(';')

            for (var i=1; i<lines.length; i++) {
                var entries = lines[i].split(';')
                var targets = []
                for (var j=3; j<entries.length; j+=2) {
                    targets.push(entries[j])
                }
                graph.nodes.set(entries[1], createNode(entries[1], entries[0], null, null, targets))
            }

            console.log(graph.nodes)

            // var node_filter = "+ POST /recipes /recipes/{sourceSystem}"
            var node_filter = "datastoreDelete"

            var nodes = new Map()

            console.log(graph.nodes.get(node_filter))

            getFrom(graph.nodes, node_filter, nodes, -1, 0)

            var current_node = graph.nodes.get(node_filter)
            current_node.x = 0
            current_node.y = 0
            nodes.set(node_filter, current_node)

            getTo(graph.nodes, node_filter, nodes, 1, 0)
            var links = getLinks(nodes)

            var norm = Math.abs(min)


            console.log(nodes)
            console.log(min)
            console.log(links)

            var svg = d3.select("svg"),
                width = +svg.attr("width"),
                height = +svg.attr("height");

            var color = d3.scaleOrdinal(d3.schemeCategory20);

            // links
            var link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("x1", function(d){return ((d.x1 + norm) * dist_h) + node_width;})
                .attr("x2", function(d){return (d.x2 + norm) * dist_h;})
                .attr("y1", function(d){return (d.y1 * dist_v) + (node_heigth / 2);})
                .attr("y2", function(d){return (d.y2 * dist_v) + (node_heigth / 2);})
                .attr("stroke-width", 2)
                .attr("stroke", "black");

            var nodes_array = Array.from(nodes.values())

            // nodes
            var node = svg.append("g")
                .selectAll("g")
                .data(nodes_array.filter(function(node) {return node.type === "Node"}))
                .enter().append("g")

            var square = node.append("rect")
                .attr("x", function(d) {return ((d.x + norm) * dist_h);})
                .attr("y", function(d) {return (d.y * dist_v);})
                .attr("width", node_width)
                .attr("height", node_heigth)
                .attr("fill", function(d) { return color(d.color); })      

            var labels = node.append("text")
                .text(function(d) {return d.id;})
                .attr('x', function(d) {return ((d.x + norm) * dist_h) + 5;})
                .attr('y', function(d) {return (d.y * dist_v) + (node_heigth / 2) + 5;});

            // entrypoints
            var entrypoint = svg.append("g")
                .selectAll("g")
                .data(nodes_array.filter(function(node) {return node.type === "Entrypoint"}))
                .enter().append("g")

            var circle_entry = entrypoint.append("circle")
                .attr("cx", function(d) {return ((d.x + norm) * dist_h) + (node_width - radio);})
                .attr("cy", function(d) {return (d.y * dist_v) + (node_heigth/2);})
                .attr("r", radio)
                .attr("fill", function(d) { return color(d.color); })

            var labels = entrypoint.append("text")
                .text(function(d) {return d.id;})
                .attr('x', function(d) {return ((d.x + norm) * dist_h) + 5;})
                .attr('y', function(d) {return (d.y * dist_v) + (node_heigth / 2) + 5;});

            // exitpoints
            var exitpoint = svg.append("g")
                .selectAll("g")
                .data(nodes_array.filter(function(node) {return node.type === "Exitpoint"}))
                .enter().append("g")

            var circle_exit = exitpoint.append("circle")
                .attr("cx", function(d) {return ((d.x + norm) * dist_h) + radio;})
                .attr("cy", function(d) {return (d.y * dist_v) + (node_heigth/2);})
                .attr("r", radio)
                .attr("fill", function(d) { return color(d.color); })

            var labels = exitpoint.append("text")
                .text(function(d) {return d.id;})
                .attr('x', function(d) {return ((d.x + norm) * dist_h) + 5 + radio*2;})
                .attr('y', function(d) {return (d.y * dist_v) + (node_heigth / 2) + 5;});
        }       
    });

});


/**
* Creates new link object with coordinates of source and target nodes
*/
function createLink(x1, y1, x2, y2) {
    return link = {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
    }
}

/**
* Creates new node object with coordinates
*/
function createNode(id, type, x, y, targets) {
    return {
        type: type,
        id: id,
        color: $(colors).attr(type),
        x: x,
        y: y,
        targets: targets
    }
}

/**
* Computes recursively all source nodes from current node until first node in graph
*/
function getFrom(nodes, node_name, res, x, y) {
    nodes.forEach(function(node, i) {
        if (($.inArray(node_name, node.targets) !== -1) && res.get(node.id) == undefined) {
            node.x = x
            node.y = y
            res.set(node.id, node)
            min = Math.min(x, min)
            getFrom(nodes, node.id, res, x-1, y)
            y++
        }
    });
}

/**
* Computes recursively all target nodes from current node until last node in graph
*/
function getTo(nodes, node_name, res, x) {
    var current_node = res.get(node_name)

    current_node.targets.forEach(function(target, i) {
        nodes.forEach(function(node, j) {
            if ((node.id == target) && res.get(node.id) == undefined) {
                node.x = x
                node.y = coords[x]
                res.set(node.id, node)
                getTo(nodes, node.id, res, x+1)
                coords[x]++
            }
        });
    });
}

function getLinks(nodes) {
    var links = []
    nodes.forEach(function(source, i) {
        source.targets.forEach(function(target_id, j) {
            var target = nodes.get(target_id)
            if (target != undefined) {
                links.push(createLink(source.x, source.y, target.x, target.y))
            }
        });
    });

    return links
}

</script>
