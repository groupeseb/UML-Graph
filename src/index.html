<!DOCTYPE html>
<meta charset="utf-8">
<style>

.links line {
    stroke: #999;
    stroke-opacity: 0.6;
}

.nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
}

text {
    font-family: sans-serif;
    font-size: 10px;
}
    
</style>
<svg width="2048" height="1024"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script>

var graph = {
    nodes: [],
    links: []
}

$(document).ready(function(){
    $.ajax({
        type: "GET" ,
        url: "routes.csv" ,
        dataType: "text" ,
        success: function(csv) {

            var lines = csv.split(/\r\n|\n/)
            var header = lines[0].split(';')

            for (var i=1; i<lines.length; i++) {
                var entries = lines[i].split(';')
                graph.nodes.push(create_node(entries[0], entries[1]))
                for (var j=3; j<entries.length; j+=2) {
                    graph.links.push(create_link(entries[1], entries[j]))
                }
            }

            var node_filter = "datastoreDelete"
            var res = []


            get_from(graph.links, node_filter, res)

            get_to(graph.links, node_filter, res)

            var nodes = get_nodes(graph.nodes, res)

            console.log(nodes)

            graph.nodes = nodes
            graph.links = res

            var svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

            var color = d3.scaleOrdinal(d3.schemeCategory20);

            var simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(function(d) { return d.id; }))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter(width / 2, height / 2));


            var link = svg.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(graph.links)
                .enter().append("line")
                .attr("stroke-width", function(d) { return Math.sqrt(d.value); });

            var node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(graph.nodes)
                .enter().append("g")

            var circles = node.append("circle")
                .attr("r", 10)
                .attr("fill", function(d) { return color(d.group); })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            var labels = node.append("text")
                .text(function(d) {
                    return d.id;
                })
                .attr('x', 10)
                .attr('y', 3);

            node.append("title")
                .text(function(d) { return d.id; });

            simulation
                .nodes(graph.nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(graph.links);

                function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
                .attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
                })
            }

            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }  
        }       
    });

});

function create_node(node_type, node_id) {
    var node = {
        type: node_type,
        id: node_id,
        group: node_type.length
    }

    return node
}

function create_link(s, t) {
    var link = {
        source: s,
        target: t,
        value: 2
    }

    return link
}

function get_from(links, node_name, arr) {
    links.forEach(function(l, i) {
        if (l.target === node_name) {
            arr.push(l)       
            if (l.source !== undefined) {
                get_from(links, l.source, arr)
            }
        }
    });

    return arr
}

function get_to(links, node_name, arr) {
    links.forEach(function(l) {
        if (l.source === node_name) {
            arr.push(l)
            if (l.target !== undefined) {
                get_to(links, l.target, arr)
            }
        }
    });

    return arr
}

function get_nodes(nodes, links) {
    var res = []
    $.each(links, function(i, l) {
        $.each(nodes, function(j, n) {
            if ($.inArray(n, res) === -1 && (l.source === n.id || l.target === n.id)) {
                res.push(n)
            }
        });
    });

    return res
}

</script>
